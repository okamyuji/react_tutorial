# 5. useEffect: データフェッチとライフサイクル

- この章では、React Hooks の中でも非常に重要なHookである `useEffect` を詳しく学びます。
- `useEffect` は、関数コンポーネントで副作用 (side effect) を扱うためのHookで、データフェッチ、DOM操作、タイマー処理など、コンポーネントのライフサイクルに関連する様々な処理を記述することができます。
- データフェッチの実装を通して、`useEffect` の基本構文、使い方、そして副作用処理とライフサイクルの原理を理解していきましょう。

## 5.1 useEffect の基本構文と使い方 (副作用処理、依存配列)

`useEffect` は、関数コンポーネント内で副作用 (side effect) を実行するためのHookです。副作用とは、コンポーネントのレンダリングとは直接関係のない処理のことで、例えば以下のようなものがあります。

- **データフェッチ**: API からデータを取得する。
- **DOM操作**: ドキュメントのタイトルを変更する、要素のスタイルを変更する。
- **タイマー処理**: `setTimeout` や `setInterval` を使用してタイマーを設定する。
- **イベントリスナー**: イベントリスナーを追加・削除する。
- **ログ出力**: `console.log` を使用してログを出力する (開発時など)。

`useEffect` を使うことで、これらの副作用を関数コンポーネント内で安全かつ効率的に扱うことができます。

### useEffect の基本構文

```jsx
import { useEffect } from 'react';

useEffect(() => {
  // 副作用処理 (例: データフェッチ、DOM操作など)
  // ...

  return () => {
    // クリーンアップ関数 (省略可能)
    // 副作用の後処理 (例: タイマーのクリア、イベントリスナーの削除など)
    // ...
  };
}, [依存配列]); // 依存配列 (省略可能)
```

- **`useEffect`**: ReactからインポートするHookです。
- **第1引数: コールバック関数**: 副作用処理を記述する関数です。この関数は、コンポーネントのレンダリング後に実行されます。
    - **戻り値 (省略可能): クリーンアップ関数**: コールバック関数が関数を返す場合、その関数はクリーンアップ関数として扱われます。クリーンアップ関数は、副作用の後処理 (例: タイマーのクリア、イベントリスナーの削除など) を行うために使用され、コンポーネントがアンマウントされる時や、次の副作用が実行される前に実行されます。
- **第2引数: 依存配列 (省略可能)**: 副作用の実行タイミングを制御するための配列です。依存配列に指定した変数のいずれかが変更された場合にのみ、副作用が再実行されます。依存配列を省略した場合や空配列 `[]` を指定した場合で、副作用の実行タイミングが異なります (詳細は後述)。

### useEffect の使い方

1. **`useEffect` をインポート**: `react` パッケージから `useEffect` をインポートします。
2. **`useEffect` を呼び出す**: 関数コンポーネント内で `useEffect(callback, dependencyArray)` を呼び出し、第1引数に副作用処理を記述したコールバック関数、第2引数に依存配列 (必要に応じて) を渡します。
3. **副作用処理を記述**: コールバック関数内に、実行したい副作用処理を記述します (例: データフェッチ、DOM操作など)。
4. **クリーンアップ関数 (必要に応じて)**: コールバック関数が副作用の後処理が必要な場合 (例: タイマーのクリア、イベントリスナーの削除など)、関数を返し、その関数内にクリーンアップ処理を記述します。
5. **依存配列 (必要に応じて)**: 副作用の実行タイミングを制御したい場合は、依存配列を指定します。依存配列に指定した変数のいずれかが変更された場合にのみ、副作用が再実行されます。

## 5.2 副作用とは？ (DOM操作、データフェッチ、タイマー処理など)

- 副作用とは、コンポーネントのレンダリングという主要な目的以外で行われる処理のことです。
- Reactコンポーネントは、propsとstateに基づいてUIを描画することに専念するべきですが、実際には、UIの描画以外にも様々な処理が必要になる場合があります。これらが副作用と呼ばれるものです。

### 副作用の例

- **DOM操作**:
    - ドキュメントのタイトルを変更する (`document.title = '新しいタイトル';`)
    - 要素のスタイルを変更する (`element.style.color = 'red';`)
    - スクロール位置を操作する (`window.scrollTo(0, 0);`)
    - input要素にフォーカスを当てる (`inputElement.focus();`)
    - これらは、コンポーネントのレンダー出力 (JSX) を直接操作するのではなく、ブラウザの DOM を直接操作する処理であり、副作用となります。

- **データフェッチ**:
    - API エンドポイントからデータを取得する (`fetch('/api/data').then(...)`)
    - 外部サービス (データベース、バックエンドサーバーなど) からデータを取得する処理は、コンポーネントのレンダー処理とは独立して行う必要があり、副作用となります。

- **タイマー処理**:
    - `setTimeout` を使用して一定時間後に処理を実行する
    - `setInterval` を使用して一定時間間隔で処理を繰り返し実行する
    - タイマー処理は、時間経過によってコンポーネントの状態やUIを変化させるために使用されますが、レンダー処理とは非同期的に行われるため、副作用となります。

- **イベントリスナー**:
    - `addEventListener` を使用してDOM要素にイベントリスナーを追加する
    - `removeEventListener` を使用してイベントリスナーを削除する
    - イベントリスナーは、ユーザーの操作やブラウザのイベントに反応して処理を実行するために使用されますが、レンダー処理とはイベント駆動で行われるため、副作用となります。

これらの副作用は、コンポーネントのライフサイクル (マウント、更新、アンマウント) に合わせて適切に管理する必要があります。`useEffect` Hookは、これらの副作用を関数コンポーネント内でライフサイクルに合わせて管理するための機能を提供します。

## 5.3 useEffect の実行タイミング (マウント時、更新時、アンマウント時)

`useEffect` に渡す依存配列の種類によって、副作用の実行タイミングが異なります。

### 依存配列の種類と実行タイミング

1. **依存配列を省略した場合 (useEffect(callback))**:
    - **初回レンダー後 (マウント時)**: コールバック関数が実行されます。
    - **毎回のレンダー後 (更新時)**: コンポーネントが再レンダリングされるたびに、コールバック関数が実行されます。
    - **アンマウント時**: クリーンアップ関数 (コールバック関数が返す関数) が実行されます (存在する場合)。

2. **依存配列を空配列 `[]` で指定した場合 (useEffect(callback, []))**:
    - **初回レンダー後 (マウント時)**: コールバック関数が実行されます (**初回のみ**)。
    - **更新時**: コールバック関数は**実行されません**。
    - **アンマウント時**: クリーンアップ関数 (コールバック関数が返す関数) が実行されます (存在する場合)。

3. **依存配列に変数 `[var1, var2, ...]` を指定した場合 (useEffect(callback, [var1, var2, ...]))**:
    - **初回レンダー後 (マウント時)**: コールバック関数が実行されます。
    - **更新時**: 依存配列に指定された変数 `var1`, `var2`, ... のいずれかの値が、前回のレンダー後から変更された場合にのみ、コールバック関数が実行されます。
    - **アンマウント時**: クリーンアップ関数 (コールバック関数が返す関数) が実行されます (存在する場合)。**ただし、変数の値が変更されて副作用が再実行される場合、新しい副作用が実行される前に、前回の副作用のクリーンアップ関数が実行されます。**

### 図解

| 依存配列 | 初回レンダー後 (マウント時) | 更新時 | アンマウント時 |
|---|---|---|---|
| 省略 | 実行 | 毎回実行 | クリーンアップ関数実行 |
| `[]` (空配列) | 実行 (初回のみ) | 実行しない | クリーンアップ関数実行 |
| `[変数]` | 実行 | 依存変数が変更された場合のみ実行 | クリーンアップ関数実行 (変数が変更されて再実行される場合、前回のクリーンアップ関数が実行される) |

### useEffect の実行タイミングの使い分け

- **マウント時のみ実行したい副作用**: 依存配列を `[]` (空配列) で指定します (例: 初回データフェッチ、イベントリスナーの初期設定など)。
- **コンポーネントの更新時に特定の変数の変更に応じて再実行したい副作用**: 依存配列に監視したい変数を指定します (例: props や state の変更に応じてデータを再フェッチするなど)。
- **毎回のレンダー後に実行したい副作用 (基本的には避けるべき)**: 依存配列を省略します。ただし、無限ループに陥る可能性があるため、注意が必要です。通常は、依存配列を適切に指定して、副作用の実行を制御することが推奨されます。

## 5.4 依存配列の役割と指定方法 (空配列、変数を指定した場合、省略した場合の違い)

依存配列は、`useEffect` Hookの動作を理解する上で非常に重要な概念です。依存配列を適切に指定することで、副作用の実行タイミングを細かく制御し、パフォーマンスの最適化や意図しない副作用の発生を防ぐことができます。

### 依存配列の役割

依存配列は、`useEffect` に渡すコールバック関数が依存する変数を指定するためのものです。React は、依存配列に指定された変数の値を監視し、前回のレンダー後から値が変更されたかどうかをチェックします。値が変更された場合、`useEffect` に渡されたコールバック関数を再実行します。

### 依存配列の指定方法と違い

1. **空配列 `[]`**

    ```jsx
    useEffect(() => {
    // マウント時のみ実行される副作用
    console.log('Component mounted');
    return () => {
        // アンマウント時のクリーンアップ
        console.log('Component unmounted');
        };
    }, []); // 空配列を指定
    ```

    - **意味**: 「この副作用は、**初回レンダー後 (マウント時) に一度だけ実行**し、依存する変数は**ない**」という意味になります。
    - **動作**: コンポーネントがマウントされた直後にコールバック関数が実行されます。コンポーネントが更新されてもコールバック関数は再実行されません。アンマウント時にクリーンアップ関数が実行されます (存在する場合)。
    - **ユースケース**:
        - コンポーネントのマウント時に一度だけ実行したい処理 (例: 初回データフェッチ、イベントリスナーの初期設定など)。
        - アンマウント時にのみ実行したいクリーンアップ処理 (例: イベントリスナーの削除、タイマーのクリアなど)。

2. **変数を指定した場合 `[var1, var2, ...]`**

    ```jsx
    import React, { useState, useEffect } from 'react';

    const ExampleComponent = ({ userId }) => {
        const [userData, setUserData] = useState(null);

        useEffect(() => {
        // userId が変更されたらデータフェッチを実行
        console.log('Fetching user data for userId:', userId);
        fetch(`/api/users/${userId}`)
            .then(res => res.json())
            .then(data => setUserData(data));
        return () => {
            // クリーンアップ処理 (例: fetch のキャンセル) (今回は省略)
            console.log('Cleanup for userId:', userId); // userId が変更される前に実行される
        };
        }, [userId]); // userId を依存配列に指定

        // ... コンポーネントのレンダー処理 ...
    };
    ```

    - **意味**: 「この副作用は、**初回レンダー後 (マウント時) に実行**し、その後は **`userId` 変数の値が変更された場合にのみ再実行**する。依存する変数は `userId` である」という意味になります。
    - **動作**: コンポーネントがマウントされた直後にコールバック関数が実行されます。その後、`userId` props の値が変更されるたびに、コールバック関数が再実行されます。`userId` が変更されて副作用が再実行される場合、新しい副作用が実行される前に、前回の副作用のクリーンアップ関数が実行されます (存在する場合)。
    - **ユースケース**:
        - props や state の値が変更されたときに、それに応じて副作用を再実行したい場合 (例: props の `userId` が変更されたらユーザーデータを再フェッチする、state の検索キーワードが変更されたら検索結果を再取得するなど)。
        - 特定の変数の値が変更されるたびにクリーンアップ処理を行いたい場合。

3. **依存配列を省略した場合 (useEffect(callback))**:

    ```jsx
    useEffect(() => {
    // 毎回のレンダー後に実行される副作用 (注意が必要)
    console.log('Component rendered');
     return () => {
       // 毎回のレンダー前のクリーンアップ (注意が必要)
       console.log('Cleanup before render');
     };
    }); // 依存配列を省略
    ```

    - **意味**: 「この副作用は、**初回レンダー後 (マウント時) に実行**し、その後は **毎回のレンダー後に再実行**する。依存する変数は**全て**である」という意味になります (実際には、依存配列を指定しない場合は、React は依存関係を自動的に推論しません)。
    - **動作**: コンポーネントがマウントされた直後、および毎回の再レンダリング後にコールバック関数が実行されます。毎回のレンダー前にクリーンアップ関数が実行されます (存在する場合)。
    - **注意点**: 依存配列を省略すると、毎回のレンダー後に副作用が実行されるため、パフォーマンス上の問題や無限ループ (副作用内で状態更新を行い、それが再レンダリングを引き起こし、再び副作用が実行される、という無限ループ) に陥る可能性があります。**基本的には、依存配列を省略することは推奨されません。**副作用が本当に毎回のレンダー後に実行する必要がある場合にのみ、慎重に使用してください。ほとんどの場合、空配列 `[]` または変数を指定した依存配列を使用することで、より意図どおりの動作を実現できます。

### **依存配列を指定する際の注意点**

- **不要な再実行を避ける**: 副作用が依存しない変数は、依存配列に含めないようにします。不要な変数を依存配列に含めると、意図せず副作用が再実行され、パフォーマンスが悪化する可能性があります。
- **最新の state と props を参照**: 依存配列に state や props を指定することで、副作用内で常に最新の state と props を参照できます。依存配列を指定しない場合、クロージャーの原理により、副作用内で参照する state や props が古い値になる可能性があります。
- **関数を依存配列に含める場合**: 関数を依存配列に含める場合、関数がレンダーごとに再生成される可能性があるため、`useCallback` Hookで関数をメモ化することを検討してください (後述の `useCallback` の章で詳しく解説します)。

## 5.5 クリーンアップ関数 (副作用の後処理、メモリーリーク対策)

`useEffect` のコールバック関数が関数を返す場合、その関数は**クリーンアップ関数**として扱われます。クリーンアップ関数は、副作用の後処理を行うために使用され、主に以下の目的で使用されます。

- **メモリーリークの防止**:
    - タイマー (例: `setTimeout`, `setInterval`) をクリアする。
    - イベントリスナー (`addEventListener`) を削除する (`removeEventListener`)。
    - データフェッチのリクエストをキャンセルする (fetch API の `AbortController` などを使用)。
    - これらの処理をクリーンアップ関数で行わない場合、コンポーネントがアンマウントされた後もタイマーが動き続けたり、イベントリスナーが残り続けたり、未完了のデータフェッチリクエストがバックグラウンドで実行され続けたりする可能性があり、メモリーリークにつながる可能性があります。

- **副作用の実行前の後処理**:
    - 依存配列に指定された変数が変更されて副作用が再実行される場合、**新しい副作用が実行される前に、前回の副作用のクリーンアップ関数が実行されます。**これにより、古い副作用が新しい副作用と競合したり、不要な処理が重複して実行されたりするのを防ぐことができます。

### クリーンアップ関数の実行タイミング

- **コンポーネントがアンマウントされる時**: コンポーネントがDOMから削除される直前に、クリーンアップ関数が実行されます。
- **副作用が再実行される前 (依存配列に変数が指定されている場合)**: 依存配列に指定された変数の値が変更され、副作用が再実行される場合、**新しい副作用が実行される前に、前回の副作用のクリーンアップ関数が実行されます。**

### **クリーンアップ関数の例 (タイマーのクリア)**

```jsx
import React, { useState, useEffect } from 'react';

const TimerComponent = () => {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    console.log('useEffect: タイマー開始');
    const timerId = setInterval(() => {
      setSeconds(prevSeconds => prevSeconds + 1);
    }, 1000);

    return () => {
      // クリーンアップ関数: タイマーをクリア
      console.log('Cleanup: タイマー停止');
      clearInterval(timerId);
    };
  }, []); // 空配列を指定 (マウント時のみタイマーを開始)

  return (
    <div>
      <p>経過時間: {seconds} 秒</p>
    </div>
  );
};
```

- **`useEffect(() => { ... return () => { ... }; }, []);`**: `useEffect` のコールバック関数が関数を返しています。これがクリーンアップ関数です。
- **`const timerId = setInterval(...)`**: `setInterval` で1秒ごとに `seconds` をインクリメントするタイマーを開始し、タイマーID (`timerId`) を取得します。
- **`return () => { clearInterval(timerId); };`**: クリーンアップ関数内で `clearInterval(timerId)` を呼び出し、タイマーをクリアしています。
- **実行タイミング**:
    - コンポーネントがマウントされると、`useEffect` が実行され、タイマーが開始されます。
    - コンポーネントがアンマウントされると、クリーンアップ関数が実行され、タイマーがクリアされます。これにより、コンポーネントがアンマウントされた後もタイマーが動き続けるメモリーリークを防ぐことができます。

### **クリーンアップ関数を記述するべき副作用**

- タイマー (`setTimeout`, `setInterval`)
- イベントリスナー (`addEventListener`)
- データフェッチ (キャンセル可能な場合)
- WebSocket 接続 など、コンポーネントがアンマウントされた後もリソースを消費し続ける可能性のある副作用は、クリーンアップ関数を記述して後処理を行うことが重要です。

## 5.6 データフェッチを useEffect で行う (APIリクエスト、ローディング/エラー処理)

`useEffect` を使って、API からデータを取得するデータフェッチ処理を実装してみましょう。ここでは、JSONPlaceholder ([https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)) という無料のREST API を使用します。

### **コード例: ユーザーリストを取得して表示するコンポーネント**

```jsx
import React, { useState, useEffect } from 'react';

interface User {
  id: number;
  name: string;
  email: string;
}

const UserListComponent = () => {
  const [users, setUsers] = useState<User[]>([]); // ユーザーリストの状態 (初期値は空配列)
  const [loading, setLoading] = useState(true); // ローディング状態 (初期値は true)
  const [error, setError] = useState<Error | null>(null); // エラー状態 (初期値は null)

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true); // ローディング開始
      setError(null); // エラーリセット
      try {
        const response = await fetch('<https://jsonplaceholder.typicode.com/users>');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data: User[] = await response.json();
        setUsers(data); // ユーザーリストを状態にセット
      } catch (e) {
        setError(e instanceof Error ? e : new Error('An unexpected error occurred')); // エラー処理
      } finally {
        setLoading(false); // ローディング終了 (成功/失敗に関わらず)
      }
    };

    fetchData(); // データフェッチ関数を実行
  }, []); // 空配列を指定 (マウント時のみデータフェッチ)

  if (loading) {
    return <p>Loading users...</p>; // ローディング中はローディングメッセージを表示
  }

  if (error) {
    return <p>Error fetching users: {error.message}</p>; // エラー発生時はエラーメッセージを表示
  }

  return (
    <div>
      <h1>ユーザーリスト</h1>
      <ul>
        {users.map(user => (
          <li key={user.id}>
            {user.name} ({user.email})
          </li>
        ))}
      </ul>
    </div>
  );
};

export default UserListComponent;
```

### **コード解説**

- **状態変数**:
    - `users`: 取得したユーザーリストを格納する状態変数 (`User[]` 型の配列、初期値は空配列 `[]`)。
    - `loading`: データフェッチ中かどうかを示すローディング状態 (`boolean` 型、初期値は `true`)。
    - `error`: エラーが発生した場合にエラーオブジェクトを格納するエラー状態 (`Error | null` 型、初期値は `null`)。
- **`useEffect(() => { ... }, []);`**: `useEffect` Hookを空配列 `[]` を依存配列として指定し、マウント時のみデータフェッチを行うように設定します。
- **`fetchData` 関数 (async/await)**: データフェッチ処理を行う非同期関数を定義します。
    - `setLoading(true);`: データフェッチ開始前にローディング状態を `true` に設定します。
    - `setError(null);`: データフェッチ開始前にエラー状態を `null` にリセットします。
    - `try...catch...finally`: エラーハンドリングのために `try...catch...finally` ブロックを使用します。
    - `fetch('https://jsonplaceholder.typicode.com/users')`: `fetch` API でユーザーリストを取得します。
    - `if (!response.ok) { throw new Error(...) }`: レスポンスがエラー (ステータスコードが 2xx 以外) の場合、エラーを throw します。
    - `const data: User[] = await response.json();`: レスポンスを JSON 形式でパースし、`User[]` 型として型アサーションします。
    - `setUsers(data);`: 取得したユーザーリストを `users` 状態変数にセットします。
    - `catch (e)`: エラーが発生した場合、`setError(e instanceof Error ? e : new Error('An unexpected error occurred'));` でエラー状態をセットします。`e instanceof Error ? e : new Error(...)` で、catch されたエラーが `Error` オブジェクトかどうかをチェックし、そうでない場合は新しい `Error` オブジェクトを作成してセットします。
    - `finally { setLoading(false); }`: `finally` ブロック内で `setLoading(false);` を呼び出し、データフェッチの成功/失敗に関わらずローディング状態を `false` に設定します。
    - `fetchData();`: 定義した `fetchData` 関数を `useEffect` のコールバック関数内で実行します。
- **レンダー処理**:
    - `if (loading) { return <p>Loading users...</p>; }`: ローディング状態が `true` の場合は、「Loading users...」というローディングメッセージを表示します。
    - `if (error) { return <p>Error fetching users: {error.message}</p>; }`: エラー状態が `null` でない (エラーが発生した場合) は、「Error fetching users: ...」というエラーメッセージを表示します。
    - それ以外の場合 (ローディング状態が `false` かつエラー状態が `null` の場合)、ユーザーリストを `<ul>` 要素で表示します。

この例では、`useEffect` を使ってコンポーネントのマウント時にデータフェッチを行い、ローディング状態とエラー状態を管理することで、ユーザーエクスペリエンスを向上させています。

## 5.7 練習問題: API からデータを取得して表示するコンポーネントを作成してみよう (JSONPlaceholder など利用)

### **問題**

JSONPlaceholder ([https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)) の `/posts` エンドポイントから投稿リストを取得して表示するReactコンポーネント `PostListComponent` を作成してください。

コンポーネントには、以下の機能を含めてください。

1. **投稿リストの表示**: 取得した投稿リストを `<ul>` 要素でリスト表示する。各リストアイテムには、投稿のタイトル (`title`) を表示する。
2. **ローディング表示**: データフェッチ中は、「Loading posts...」というローディングメッセージを表示する。
3. **エラー表示**: データフェッチ中にエラーが発生した場合は、「Error fetching posts: ...」というエラーメッセージを表示する (エラーメッセージには、エラーオブジェクトの `message` プロパティを表示する)。

`useEffect` Hookを使用してデータフェッチ処理を実装し、`useState` Hookを使用して投稿リスト、ローディング状態、エラー状態を管理してください。

### **ヒント**

- `PostListComponent` コンポーネントを作成する。
- `useState` を使って、投稿リスト (`posts` - 配列)、ローディング状態 (`loading` - boolean)、エラー状態 (`error` - Error or null) の状態変数を宣言する。
- `useEffect` Hookを使用して、コンポーネントのマウント時にデータフェッチ処理を行う。依存配列は `[]` (空配列) を指定する。
- `fetch` API を使用して `https://jsonplaceholder.typicode.com/posts` エンドポイントからデータを取得する。
- `async/await` を使用して非同期処理を記述する。
- `try...catch...finally` ブロックでエラーハンドリングとローディング状態の管理を行う。
- ローディング状態、エラー状態、投稿リストの状態に基づいて、レンダー内容を条件分岐する。

---

## 5.8 復習問題

**問題1**: `useEffect` Hookの説明として**誤っている**ものを選びなさい。

a) 関数コンポーネントで副作用を扱うためのHookである。
b) コールバック関数と依存配列を引数として取る。
c) コールバック関数は、コンポーネントのレンダー処理と同期的に実行される。
d) 依存配列を指定することで、副作用の実行タイミングを制御できる。

**問題2**: 次の `useEffect` Hookの実行タイミングとして正しいものを選びなさい。

```jsx
useEffect(() => {
  console.log('Effect executed');
}, []);
```

a) 毎回のレンダー後
b) 初回レンダー後 (マウント時) のみ
c) コンポーネントがアンマウントされる時のみ
d) 依存配列に指定された変数が変更された時のみ

**問題3**: `useEffect` のクリーンアップ関数の説明として**誤っている**ものを選びなさい。

a) 副作用の後処理を行うための関数である。
b) `useEffect` のコールバック関数が返す関数として定義する。
c) コンポーネントがアンマウントされる時や、副作用が再実行される前に実行される。
d) 副作用の実行前に必ず実行される。

**問題4**: データフェッチを `useEffect` で行う際に、ローディング状態とエラー状態を管理する理由として**最も適切な**ものを選びなさい。

a) コードの可読性を向上させるため。
b) Reactのベストプラクティスに従うため。
c) ユーザーエクスペリエンスを向上させるため (ローディング表示、エラーメッセージ表示)。
d) データフェッチ処理を非同期的に行うため。

## 5.9 復習問題の解説と解答

**問題1 解答: c) コールバック関数は、コンポーネントのレンダー処理と同期的に実行される。**

- **解説**:
    - a), b), d) は `useEffect` Hookに関する**正しい**説明です。
    - c) は**誤り**です。`useEffect` Hookのコールバック関数は、コンポーネントのレンダー処理と**非同期的に**実行されます。React はまずレンダー処理を完了させ、ブラウザに画面を更新した後、`useEffect` のコールバック関数をスケジュールして実行します。これにより、副作用処理がレンダー処理をブロックするのを防ぎ、UI のレスポンス性能を維持します。

**問題2 解答: b) 初回レンダー後 (マウント時) のみ**

- **解説**:
    - 依存配列に空配列 `[]` を指定した場合、`useEffect` Hookのコールバック関数は、**初回レンダー後 (マウント時) に一度だけ実行**されます。コンポーネントが更新されてもコールバック関数は再実行されません。
    - a), c), d) は、空配列 `[]` を指定した場合の `useEffect` の実行タイミングとしては**誤り**です。

**問題3 解答: d) 副作用の実行前に必ず実行される。**

- **解説**:
    - a), b), c) は `useEffect` のクリーンアップ関数に関する**正しい**説明です。
    - d) は**誤り**です。クリーンアップ関数は、**副作用が再実行される場合 (依存配列に変数が指定されている場合) は、新しい副作用が実行される前に実行されますが、初回レンダー時には実行されません。**また、依存配列を空配列 `[]` で指定した場合、副作用は初回レンダー時のみ実行され、再実行されないため、クリーンアップ関数はコンポーネントがアンマウントされる時のみ実行されます。

**問題4 解答: c) ユーザーエクスペリエンスを向上させるため (ローディング表示、エラーメッセージ表示)。**

- **解説**:
    - データフェッチは非同期処理であり、API リクエストに時間がかかる場合があります。ローディング状態を管理し、ローディング表示を行うことで、ユーザーに処理中であることを伝え、待ち時間のストレスを軽減できます。
    - また、データフェッチ中にエラーが発生する可能性もあります。エラー状態を管理し、エラーメッセージを表示することで、ユーザーにエラーが発生したことを伝え、適切な対処 (例: 再試行、開発者への連絡など) を促すことができます。
    - a), b), d) も一部は理由として考えられますが、**最も直接的かつ重要な理由は、ユーザーエクスペリエンスの向上**です。

以上が「useEffect」の章です。`useEffect` の基本的な使い方、副作用の種類、実行タイミング、依存配列の役割、クリーンアップ関数、データフェッチへの応用などを理解できたでしょうか？
次の章では、Context API と `useContext` Hoo を使って、コンポーネントツリー全体でグローバルな状態を共有する方法を学びます。

---
